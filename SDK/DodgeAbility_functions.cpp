#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DodgeAbility

#include "Basic.hpp"

#include "DodgeAbility_classes.hpp"
#include "DodgeAbility_parameters.hpp"


namespace SDK
{

// Function DodgeAbility.DodgeAbility_C.UpdateRocketsDodged__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   RocketsDodged                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UDodgeAbility_C::UpdateRocketsDodged__DelegateSignature(int32 RocketsDodged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "UpdateRocketsDodged__DelegateSignature");

	Params::DodgeAbility_C_UpdateRocketsDodged__DelegateSignature Parms{};

	Parms.RocketsDodged = RocketsDodged;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DodgeAbility.DodgeAbility_C.ExecuteUbergraph_DodgeAbility
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UDodgeAbility_C::ExecuteUbergraph_DodgeAbility(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "ExecuteUbergraph_DodgeAbility");

	Params::DodgeAbility_C_ExecuteUbergraph_DodgeAbility Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DodgeAbility.DodgeAbility_C.ServerToggleDodgeType
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void UDodgeAbility_C::ServerToggleDodgeType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "ServerToggleDodgeType");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DodgeAbility.DodgeAbility_C.BP_OnAnyInputReceived
// (Event, Protected, BlueprintEvent)
// Parameters:
// EMarinerInputActions                    InputType                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EInputEvent                             EventType                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UDodgeAbility_C::BP_OnAnyInputReceived(EMarinerInputActions InputType, EInputEvent EventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "BP_OnAnyInputReceived");

	Params::DodgeAbility_C_BP_OnAnyInputReceived Parms{};

	Parms.InputType = InputType;
	Parms.EventType = EventType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DodgeAbility.DodgeAbility_C.BP_OnAbilityActivated
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayAbilityActorInfo        ActorInfo                                              (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference)

void UDodgeAbility_C::BP_OnAbilityActivated(const struct FGameplayAbilityActorInfo& ActorInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "BP_OnAbilityActivated");

	Params::DodgeAbility_C_BP_OnAbilityActivated Parms{};

	Parms.ActorInfo = std::move(ActorInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DodgeAbility.DodgeAbility_C.OnMegablastStateChangedOwner
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMarinerDamageableComponent*      RelevantDamageableComponent                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AMarinerPlayerState*              MegablastInstigator                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bEnteredState                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UDodgeAbility_C::OnMegablastStateChangedOwner(const class UMarinerDamageableComponent* RelevantDamageableComponent, const class AMarinerPlayerState* MegablastInstigator, bool bEnteredState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "OnMegablastStateChangedOwner");

	Params::DodgeAbility_C_OnMegablastStateChangedOwner Parms{};

	Parms.RelevantDamageableComponent = RelevantDamageableComponent;
	Parms.MegablastInstigator = MegablastInstigator;
	Parms.bEnteredState = bEnteredState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DodgeAbility.DodgeAbility_C.BP_OnActivationRejectedByServer
// (Event, Protected, BlueprintEvent)

void UDodgeAbility_C::BP_OnActivationRejectedByServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "BP_OnActivationRejectedByServer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DodgeAbility.DodgeAbility_C.BP_OnAbilityEnded
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayAbilityActorInfo        ActorInfo                                              (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference)
// bool                                    WasCancelled                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UDodgeAbility_C::BP_OnAbilityEnded(const struct FGameplayAbilityActorInfo& ActorInfo, bool WasCancelled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "BP_OnAbilityEnded");

	Params::DodgeAbility_C_BP_OnAbilityEnded Parms{};

	Parms.ActorInfo = std::move(ActorInfo);
	Parms.WasCancelled = WasCancelled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DodgeAbility.DodgeAbility_C.BP_OnOwningControllerSet
// (Event, Public, BlueprintEvent)

void UDodgeAbility_C::BP_OnOwningControllerSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "BP_OnOwningControllerSet");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DodgeAbility.DodgeAbility_C.OnPlayerReachedMegablastDanger
// (BlueprintCallable, BlueprintEvent)

void UDodgeAbility_C::OnPlayerReachedMegablastDanger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "OnPlayerReachedMegablastDanger");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DodgeAbility.DodgeAbility_C.ProcessArtifactData
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TMap<class FName, float>                Map                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UDodgeAbility_C::ProcessArtifactData(const TMap<class FName, float>& Map)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "ProcessArtifactData");

	Params::DodgeAbility_C_ProcessArtifactData Parms{};

	Parms.Map = std::move(Map);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DodgeAbility.DodgeAbility_C.SetNinjaHeadbandSlowDownTimer
// (BlueprintCallable, BlueprintEvent)

void UDodgeAbility_C::SetNinjaHeadbandSlowDownTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "SetNinjaHeadbandSlowDownTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DodgeAbility.DodgeAbility_C.SlowDownNinjaHeadbandDodge
// (BlueprintCallable, BlueprintEvent)

void UDodgeAbility_C::SlowDownNinjaHeadbandDodge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "SlowDownNinjaHeadbandDodge");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DodgeAbility.DodgeAbility_C.DodgeFinished
// (BlueprintCallable, BlueprintEvent)

void UDodgeAbility_C::DodgeFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "DodgeFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DodgeAbility.DodgeAbility_C.GetOwningController
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AMarinerPlayerController*         OwningControlller                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UDodgeAbility_C::GetOwningController(class AMarinerPlayerController** OwningControlller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "GetOwningController");

	Params::DodgeAbility_C_GetOwningController Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OwningControlller != nullptr)
		*OwningControlller = Parms.OwningControlller;
}


// Function DodgeAbility.DodgeAbility_C.GetNormalizedAcceleration
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          Acceleration                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UDodgeAbility_C::GetNormalizedAcceleration(struct FVector* Acceleration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "GetNormalizedAcceleration");

	Params::DodgeAbility_C_GetNormalizedAcceleration Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Acceleration != nullptr)
		*Acceleration = std::move(Parms.Acceleration);
}


// Function DodgeAbility.DodgeAbility_C.GetDodgeStrength
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   DodgeStrength_0                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UDodgeAbility_C::GetDodgeStrength(float* DodgeStrength_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "GetDodgeStrength");

	Params::DodgeAbility_C_GetDodgeStrength Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (DodgeStrength_0 != nullptr)
		*DodgeStrength_0 = Parms.DodgeStrength_0;
}


// Function DodgeAbility.DodgeAbility_C.GetDodgeLaunchVelocity
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector UDodgeAbility_C::GetDodgeLaunchVelocity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "GetDodgeLaunchVelocity");

	Params::DodgeAbility_C_GetDodgeLaunchVelocity Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DodgeAbility.DodgeAbility_C.GetDodgeMinLaunchAngle
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   MinLaunchAngle                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UDodgeAbility_C::GetDodgeMinLaunchAngle(float* MinLaunchAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "GetDodgeMinLaunchAngle");

	Params::DodgeAbility_C_GetDodgeMinLaunchAngle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (MinLaunchAngle != nullptr)
		*MinLaunchAngle = Parms.MinLaunchAngle;
}


// Function DodgeAbility.DodgeAbility_C.ApplyActiveEffects_MoveAffecting
// (Public, BlueprintCallable, BlueprintEvent)

void UDodgeAbility_C::ApplyActiveEffects_MoveAffecting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "ApplyActiveEffects_MoveAffecting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DodgeAbility.DodgeAbility_C.ApplyActiveEffects_Predictive
// (Public, BlueprintCallable, BlueprintEvent)

void UDodgeAbility_C::ApplyActiveEffects_Predictive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "ApplyActiveEffects_Predictive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DodgeAbility.DodgeAbility_C.RemoveActiveEffects_PredictedRejection
// (Public, BlueprintCallable, BlueprintEvent)

void UDodgeAbility_C::RemoveActiveEffects_PredictedRejection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "RemoveActiveEffects_PredictedRejection");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DodgeAbility.DodgeAbility_C.RemoveActiveEffects_Predictive
// (Public, BlueprintCallable, BlueprintEvent)

void UDodgeAbility_C::RemoveActiveEffects_Predictive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "RemoveActiveEffects_Predictive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DodgeAbility.DodgeAbility_C.RemoveActiveEffects_MoveAffecting
// (Public, BlueprintCallable, BlueprintEvent)

void UDodgeAbility_C::RemoveActiveEffects_MoveAffecting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "RemoveActiveEffects_MoveAffecting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DodgeAbility.DodgeAbility_C.IncreaseStunBreakStat
// (Public, BlueprintCallable, BlueprintEvent)

void UDodgeAbility_C::IncreaseStunBreakStat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "IncreaseStunBreakStat");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DodgeAbility.DodgeAbility_C.HandleNinjaHeadbandSlowDown
// (Public, BlueprintCallable, BlueprintEvent)

void UDodgeAbility_C::HandleNinjaHeadbandSlowDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "HandleNinjaHeadbandSlowDown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DodgeAbility.DodgeAbility_C.HandleInputQueuing
// (Public, BlueprintCallable, BlueprintEvent)

void UDodgeAbility_C::HandleInputQueuing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "HandleInputQueuing");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DodgeAbility.DodgeAbility_C.CheckForOverlappingProjectiles
// (Public, BlueprintCallable, BlueprintEvent)

void UDodgeAbility_C::CheckForOverlappingProjectiles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "CheckForOverlappingProjectiles");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DodgeAbility.DodgeAbility_C.LookForAbilitiesToEnd
// (Public, BlueprintCallable, BlueprintEvent)

void UDodgeAbility_C::LookForAbilitiesToEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "LookForAbilitiesToEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DodgeAbility.DodgeAbility_C.PredictDodgeStateApplied
// (Public, BlueprintCallable, BlueprintEvent)

void UDodgeAbility_C::PredictDodgeStateApplied()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "PredictDodgeStateApplied");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DodgeAbility.DodgeAbility_C.RemoveStun
// (Public, BlueprintCallable, BlueprintEvent)

void UDodgeAbility_C::RemoveStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "RemoveStun");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DodgeAbility.DodgeAbility_C.GetDodgeInPlaceStrength
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          DodgeInPlaceDir                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UDodgeAbility_C::GetDodgeInPlaceStrength(struct FVector* DodgeInPlaceDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "GetDodgeInPlaceStrength");

	Params::DodgeAbility_C_GetDodgeInPlaceStrength Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (DodgeInPlaceDir != nullptr)
		*DodgeInPlaceDir = std::move(Parms.DodgeInPlaceDir);
}


// Function DodgeAbility.DodgeAbility_C.AntiSelfKOLaunchModifier
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          TargetLoc                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsDodgeInPlace                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          AdjustedDodge                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UDodgeAbility_C::AntiSelfKOLaunchModifier(const struct FVector& TargetLoc, bool IsDodgeInPlace, struct FVector* AdjustedDodge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "AntiSelfKOLaunchModifier");

	Params::DodgeAbility_C_AntiSelfKOLaunchModifier Parms{};

	Parms.TargetLoc = std::move(TargetLoc);
	Parms.IsDodgeInPlace = IsDodgeInPlace;

	UObject::ProcessEvent(Func, &Parms);

	if (AdjustedDodge != nullptr)
		*AdjustedDodge = std::move(Parms.AdjustedDodge);
}


// Function DodgeAbility.DodgeAbility_C.UpdateDodgeDuration
// (Public, BlueprintCallable, BlueprintEvent)

void UDodgeAbility_C::UpdateDodgeDuration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "UpdateDodgeDuration");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DodgeAbility.DodgeAbility_C.CacheIsNinjaHeadbandActive
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UDodgeAbility_C::CacheIsNinjaHeadbandActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "CacheIsNinjaHeadbandActive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DodgeAbility.DodgeAbility_C.ApplyCharacterRecovery
// (Public, BlueprintCallable, BlueprintEvent)

void UDodgeAbility_C::ApplyCharacterRecovery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "ApplyCharacterRecovery");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DodgeAbility.DodgeAbility_C.GetInputVector
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          InputVector                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UDodgeAbility_C::GetInputVector(struct FVector* InputVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "GetInputVector");

	Params::DodgeAbility_C_GetInputVector Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (InputVector != nullptr)
		*InputVector = std::move(Parms.InputVector);
}


// Function DodgeAbility.DodgeAbility_C.GetCharacterForwardVector
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          ForwardVector                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UDodgeAbility_C::GetCharacterForwardVector(struct FVector* ForwardVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "GetCharacterForwardVector");

	Params::DodgeAbility_C_GetCharacterForwardVector Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ForwardVector != nullptr)
		*ForwardVector = std::move(Parms.ForwardVector);
}


// Function DodgeAbility.DodgeAbility_C.GetAimDirection
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          AimDirection                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UDodgeAbility_C::GetAimDirection(struct FVector* AimDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "GetAimDirection");

	Params::DodgeAbility_C_GetAimDirection Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AimDirection != nullptr)
		*AimDirection = std::move(Parms.AimDirection);
}


// Function DodgeAbility.DodgeAbility_C.CalculateDirectionalLaunchVector
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          LaunchVector                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UDodgeAbility_C::CalculateDirectionalLaunchVector(struct FVector* LaunchVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "CalculateDirectionalLaunchVector");

	Params::DodgeAbility_C_CalculateDirectionalLaunchVector Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (LaunchVector != nullptr)
		*LaunchVector = std::move(Parms.LaunchVector);
}


// Function DodgeAbility.DodgeAbility_C.RotateLaunchVectorByMinLaunchAngle
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          CombinedAimInputVector                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   CombinedAimInputVectorZ                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsPlayerMovingBackwards                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          AdjustedAimDirection                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ModifiedLaunchVector                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UDodgeAbility_C::RotateLaunchVectorByMinLaunchAngle(const struct FVector& CombinedAimInputVector, float CombinedAimInputVectorZ, bool IsPlayerMovingBackwards, const struct FVector& AdjustedAimDirection, struct FVector* ModifiedLaunchVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "RotateLaunchVectorByMinLaunchAngle");

	Params::DodgeAbility_C_RotateLaunchVectorByMinLaunchAngle Parms{};

	Parms.CombinedAimInputVector = std::move(CombinedAimInputVector);
	Parms.CombinedAimInputVectorZ = CombinedAimInputVectorZ;
	Parms.IsPlayerMovingBackwards = IsPlayerMovingBackwards;
	Parms.AdjustedAimDirection = std::move(AdjustedAimDirection);

	UObject::ProcessEvent(Func, &Parms);

	if (ModifiedLaunchVector != nullptr)
		*ModifiedLaunchVector = std::move(Parms.ModifiedLaunchVector);
}


// Function DodgeAbility.DodgeAbility_C.GetModifiedLaunchStrength
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   CombinedAimInputVectorZ                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          CombinedAimInputVector                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   ModifiedLaunchStrength                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UDodgeAbility_C::GetModifiedLaunchStrength(float CombinedAimInputVectorZ, const struct FVector& CombinedAimInputVector, float* ModifiedLaunchStrength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "GetModifiedLaunchStrength");

	Params::DodgeAbility_C_GetModifiedLaunchStrength Parms{};

	Parms.CombinedAimInputVectorZ = CombinedAimInputVectorZ;
	Parms.CombinedAimInputVector = std::move(CombinedAimInputVector);

	UObject::ProcessEvent(Func, &Parms);

	if (ModifiedLaunchStrength != nullptr)
		*ModifiedLaunchStrength = Parms.ModifiedLaunchStrength;
}


// Function DodgeAbility.DodgeAbility_C.CalculateCombinedAimInputVector
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   InputForwardVectorDot                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsPlayerMovingBackwards                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          AdjustedAimDirection                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          CombinedAimInputVector                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UDodgeAbility_C::CalculateCombinedAimInputVector(float InputForwardVectorDot, bool IsPlayerMovingBackwards, const struct FVector& AdjustedAimDirection, struct FVector* CombinedAimInputVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "CalculateCombinedAimInputVector");

	Params::DodgeAbility_C_CalculateCombinedAimInputVector Parms{};

	Parms.InputForwardVectorDot = InputForwardVectorDot;
	Parms.IsPlayerMovingBackwards = IsPlayerMovingBackwards;
	Parms.AdjustedAimDirection = std::move(AdjustedAimDirection);

	UObject::ProcessEvent(Func, &Parms);

	if (CombinedAimInputVector != nullptr)
		*CombinedAimInputVector = std::move(Parms.CombinedAimInputVector);
}


// Function DodgeAbility.DodgeAbility_C.GetPlayerInputAndActorForwardVectorDot
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   InputForwardVectorDot                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UDodgeAbility_C::GetPlayerInputAndActorForwardVectorDot(float* InputForwardVectorDot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "GetPlayerInputAndActorForwardVectorDot");

	Params::DodgeAbility_C_GetPlayerInputAndActorForwardVectorDot Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (InputForwardVectorDot != nullptr)
		*InputForwardVectorDot = Parms.InputForwardVectorDot;
}


// Function DodgeAbility.DodgeAbility_C.GetIsPlayerWalking
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    IsWalking                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UDodgeAbility_C::GetIsPlayerWalking(bool* IsWalking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "GetIsPlayerWalking");

	Params::DodgeAbility_C_GetIsPlayerWalking Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsWalking != nullptr)
		*IsWalking = Parms.IsWalking;
}


// Function DodgeAbility.DodgeAbility_C.BP_GetLaunchVector
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector UDodgeAbility_C::BP_GetLaunchVector()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "BP_GetLaunchVector");

	Params::DodgeAbility_C_BP_GetLaunchVector Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DodgeAbility.DodgeAbility_C.IsLaunchEndLocationArenaBoundsLOS_Blocked
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          ClosestPointOnBoundsSurface                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bLocked                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UDodgeAbility_C::IsLaunchEndLocationArenaBoundsLOS_Blocked(const struct FVector& ClosestPointOnBoundsSurface, bool* bLocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "IsLaunchEndLocationArenaBoundsLOS_Blocked");

	Params::DodgeAbility_C_IsLaunchEndLocationArenaBoundsLOS_Blocked Parms{};

	Parms.ClosestPointOnBoundsSurface = std::move(ClosestPointOnBoundsSurface);

	UObject::ProcessEvent(Func, &Parms);

	if (bLocked != nullptr)
		*bLocked = Parms.bLocked;
}


// Function DodgeAbility.DodgeAbility_C.GetAntiKO_FloorLaunchVector
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          TargetLoc                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ClosestBoundsNormal                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          LaunchVector                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UDodgeAbility_C::GetAntiKO_FloorLaunchVector(const struct FVector& TargetLoc, const struct FVector& ClosestBoundsNormal, struct FVector* LaunchVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "GetAntiKO_FloorLaunchVector");

	Params::DodgeAbility_C_GetAntiKO_FloorLaunchVector Parms{};

	Parms.TargetLoc = std::move(TargetLoc);
	Parms.ClosestBoundsNormal = std::move(ClosestBoundsNormal);

	UObject::ProcessEvent(Func, &Parms);

	if (LaunchVector != nullptr)
		*LaunchVector = std::move(Parms.LaunchVector);
}


// Function DodgeAbility.DodgeAbility_C.IsPlayerCloseEnoughToKOBoundsForProtectionLogic
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          PointOnClosestBounds                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    CloseEnough                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UDodgeAbility_C::IsPlayerCloseEnoughToKOBoundsForProtectionLogic(const struct FVector& PointOnClosestBounds, bool* CloseEnough)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "IsPlayerCloseEnoughToKOBoundsForProtectionLogic");

	Params::DodgeAbility_C_IsPlayerCloseEnoughToKOBoundsForProtectionLogic Parms{};

	Parms.PointOnClosestBounds = std::move(PointOnClosestBounds);

	UObject::ProcessEvent(Func, &Parms);

	if (CloseEnough != nullptr)
		*CloseEnough = Parms.CloseEnough;
}


// Function DodgeAbility.DodgeAbility_C.GetIsClosestKOBoundsFloor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          ClosestBoundsNormal                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsFloor                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UDodgeAbility_C::GetIsClosestKOBoundsFloor(const struct FVector& ClosestBoundsNormal, bool* IsFloor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "GetIsClosestKOBoundsFloor");

	Params::DodgeAbility_C_GetIsClosestKOBoundsFloor Parms{};

	Parms.ClosestBoundsNormal = std::move(ClosestBoundsNormal);

	UObject::ProcessEvent(Func, &Parms);

	if (IsFloor != nullptr)
		*IsFloor = Parms.IsFloor;
}


// Function DodgeAbility.DodgeAbility_C.GetNonFloorKOBoundsLaunchVector
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          ClosestBoundsNormal                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          TargetLoc                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          LaunchVector                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UDodgeAbility_C::GetNonFloorKOBoundsLaunchVector(const struct FVector& ClosestBoundsNormal, const struct FVector& TargetLoc, struct FVector* LaunchVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "GetNonFloorKOBoundsLaunchVector");

	Params::DodgeAbility_C_GetNonFloorKOBoundsLaunchVector Parms{};

	Parms.ClosestBoundsNormal = std::move(ClosestBoundsNormal);
	Parms.TargetLoc = std::move(TargetLoc);

	UObject::ProcessEvent(Func, &Parms);

	if (LaunchVector != nullptr)
		*LaunchVector = std::move(Parms.LaunchVector);
}


// Function DodgeAbility.DodgeAbility_C.GetNonFloorKOBoundsLaunchScalar
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    IsDodgeInPlace                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          ClosestBoundsNormal                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   LaunchScalar                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UDodgeAbility_C::GetNonFloorKOBoundsLaunchScalar(bool IsDodgeInPlace, const struct FVector& ClosestBoundsNormal, float* LaunchScalar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "GetNonFloorKOBoundsLaunchScalar");

	Params::DodgeAbility_C_GetNonFloorKOBoundsLaunchScalar Parms{};

	Parms.IsDodgeInPlace = IsDodgeInPlace;
	Parms.ClosestBoundsNormal = std::move(ClosestBoundsNormal);

	UObject::ProcessEvent(Func, &Parms);

	if (LaunchScalar != nullptr)
		*LaunchScalar = Parms.LaunchScalar;
}


// Function DodgeAbility.DodgeAbility_C.DebugDrawAntiKOBoundsChecks
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          PointOnClosestBoundsSurface                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ModifiedEndLocationWithBuffer                          (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ClosestBoundsNormal                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UDodgeAbility_C::DebugDrawAntiKOBoundsChecks(const struct FVector& PointOnClosestBoundsSurface, const struct FVector& ModifiedEndLocationWithBuffer, const struct FVector& ClosestBoundsNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "DebugDrawAntiKOBoundsChecks");

	Params::DodgeAbility_C_DebugDrawAntiKOBoundsChecks Parms{};

	Parms.PointOnClosestBoundsSurface = std::move(PointOnClosestBoundsSurface);
	Parms.ModifiedEndLocationWithBuffer = std::move(ModifiedEndLocationWithBuffer);
	Parms.ClosestBoundsNormal = std::move(ClosestBoundsNormal);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DodgeAbility.DodgeAbility_C.GetIsPointOnClosestBoundsValidForProtection
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          PointOnClosestBoundsSurface                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsValid                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UDodgeAbility_C::GetIsPointOnClosestBoundsValidForProtection(const struct FVector& PointOnClosestBoundsSurface, bool* IsValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "GetIsPointOnClosestBoundsValidForProtection");

	Params::DodgeAbility_C_GetIsPointOnClosestBoundsValidForProtection Parms{};

	Parms.PointOnClosestBoundsSurface = std::move(PointOnClosestBoundsSurface);

	UObject::ProcessEvent(Func, &Parms);

	if (IsValid != nullptr)
		*IsValid = Parms.IsValid;
}


// Function DodgeAbility.DodgeAbility_C.GetArenaBoundsRef
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AMarinerFastArenaBounds*          ArenaBounds_0                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UDodgeAbility_C::GetArenaBoundsRef(class AMarinerFastArenaBounds** ArenaBounds_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "GetArenaBoundsRef");

	Params::DodgeAbility_C_GetArenaBoundsRef Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ArenaBounds_0 != nullptr)
		*ArenaBounds_0 = Parms.ArenaBounds_0;
}


// Function DodgeAbility.DodgeAbility_C.IsNinjaHeadbandActive
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    IsActive_0                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UDodgeAbility_C::IsNinjaHeadbandActive(bool* IsActive_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "IsNinjaHeadbandActive");

	Params::DodgeAbility_C_IsNinjaHeadbandActive Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsActive_0 != nullptr)
		*IsActive_0 = Parms.IsActive_0;
}


// Function DodgeAbility.DodgeAbility_C.GetNinjaHeadbandAbility
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UItem_NinjaHeadband_ItemAbility_C*NinjaHeadbandAbility                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    CastSuccess                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UDodgeAbility_C::GetNinjaHeadbandAbility(class UItem_NinjaHeadband_ItemAbility_C** NinjaHeadbandAbility, bool* CastSuccess) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "GetNinjaHeadbandAbility");

	Params::DodgeAbility_C_GetNinjaHeadbandAbility Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NinjaHeadbandAbility != nullptr)
		*NinjaHeadbandAbility = Parms.NinjaHeadbandAbility;

	if (CastSuccess != nullptr)
		*CastSuccess = Parms.CastSuccess;
}


// Function DodgeAbility.DodgeAbility_C.GetCooldownDuration
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

float UDodgeAbility_C::GetCooldownDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "GetCooldownDuration");

	Params::DodgeAbility_C_GetCooldownDuration Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DodgeAbility.DodgeAbility_C.GetDodgeDuration
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   DodgeDuration                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UDodgeAbility_C::GetDodgeDuration(float* DodgeDuration) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "GetDodgeDuration");

	Params::DodgeAbility_C_GetDodgeDuration Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (DodgeDuration != nullptr)
		*DodgeDuration = Parms.DodgeDuration;
}


// Function DodgeAbility.DodgeAbility_C.GetAbilityUIDuration
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    bForceActiveDisplay                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

float UDodgeAbility_C::GetAbilityUIDuration(bool* bForceActiveDisplay) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "GetAbilityUIDuration");

	Params::DodgeAbility_C_GetAbilityUIDuration Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bForceActiveDisplay != nullptr)
		*bForceActiveDisplay = Parms.bForceActiveDisplay;

	return Parms.ReturnValue;
}


// Function DodgeAbility.DodgeAbility_C.BP_GetCustomTargetingInt
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UDodgeAbility_C::BP_GetCustomTargetingInt() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "BP_GetCustomTargetingInt");

	Params::DodgeAbility_C_BP_GetCustomTargetingInt Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DodgeAbility.DodgeAbility_C.IsControlledByAI (Server Only)
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UDodgeAbility_C::IsControlledByAI__Server_Only_(bool* bSuccess) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "IsControlledByAI (Server Only)");

	Params::DodgeAbility_C_IsControlledByAI__Server_Only_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;
}


// Function DodgeAbility.DodgeAbility_C.BP_GenerateAIInputVector
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// class AMarinerAIController*             RequestingController                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AMarinerCharacter*                RequestingPawn                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector UDodgeAbility_C::BP_GenerateAIInputVector(class AMarinerAIController* RequestingController, class AMarinerCharacter* RequestingPawn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DodgeAbility_C", "BP_GenerateAIInputVector");

	Params::DodgeAbility_C_BP_GenerateAIInputVector Parms{};

	Parms.RequestingController = RequestingController;
	Parms.RequestingPawn = RequestingPawn;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

