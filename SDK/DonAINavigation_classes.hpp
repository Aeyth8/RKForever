#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DonAINavigation

#include "Basic.hpp"

#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "DonAINavigation_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class DonAINavigation.BTTask_FlyTo
// 0x00B8 (0x0128 - 0x0070)
class UBTTask_FlyTo final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 FlightLocationKey;                                 // 0x0070(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 FlightResultKey;                                   // 0x0098(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 KeyToFlipFlopWhenTaskExits;                        // 0x00C0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         MinimumProximityRequired;                          // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDoNNavigationQueryParams              QueryParams;                                       // 0x00F0(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBT_FlyToTarget_DebugParams            DebugParams;                                       // 0x0110(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class ADonNavigationManager*                  NavigationManager;                                 // 0x0120(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Pathfinding_OnDynamicCollisionAlert(const struct FDonNavigationDynamicCollisionPayload& Data);
	void Pathfinding_OnFinish(const struct FDoNNavigationQueryData& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FlyTo">();
	}
	static class UBTTask_FlyTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FlyTo>();
	}
};
static_assert(alignof(UBTTask_FlyTo) == 0x000008, "Wrong alignment on UBTTask_FlyTo");
static_assert(sizeof(UBTTask_FlyTo) == 0x000128, "Wrong size on UBTTask_FlyTo");
static_assert(offsetof(UBTTask_FlyTo, FlightLocationKey) == 0x000070, "Member 'UBTTask_FlyTo::FlightLocationKey' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, FlightResultKey) == 0x000098, "Member 'UBTTask_FlyTo::FlightResultKey' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, KeyToFlipFlopWhenTaskExits) == 0x0000C0, "Member 'UBTTask_FlyTo::KeyToFlipFlopWhenTaskExits' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, MinimumProximityRequired) == 0x0000E8, "Member 'UBTTask_FlyTo::MinimumProximityRequired' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, QueryParams) == 0x0000F0, "Member 'UBTTask_FlyTo::QueryParams' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, DebugParams) == 0x000110, "Member 'UBTTask_FlyTo::DebugParams' has a wrong offset!");
static_assert(offsetof(UBTTask_FlyTo, NavigationManager) == 0x000120, "Member 'UBTTask_FlyTo::NavigationManager' has a wrong offset!");

// Class DonAINavigation.DonNavigationHelper
// 0x0000 (0x0028 - 0x0028)
class UDonNavigationHelper final : public UBlueprintFunctionLibrary
{
public:
	static class ADonNavigationManager* DonNavigationManager(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DonNavigationHelper">();
	}
	static class UDonNavigationHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDonNavigationHelper>();
	}
};
static_assert(alignof(UDonNavigationHelper) == 0x000008, "Wrong alignment on UDonNavigationHelper");
static_assert(sizeof(UDonNavigationHelper) == 0x000028, "Wrong size on UDonNavigationHelper");

// Class DonAINavigation.DonNavigator
// 0x0000 (0x0028 - 0x0028)
class IDonNavigator final : public IInterface
{
public:
	void AddMovementInputCustom(const struct FVector& WorldDirection, float ScaleValue);
	void OnLocomotionAbort();
	void OnLocomotionBegin();
	void OnLocomotionEnd();
	void OnNextSegment(const struct FVector& NextPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DonNavigator">();
	}
	static class IDonNavigator* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDonNavigator>();
	}
};
static_assert(alignof(IDonNavigator) == 0x000008, "Wrong alignment on IDonNavigator");
static_assert(sizeof(IDonNavigator) == 0x000028, "Wrong size on IDonNavigator");

// Class DonAINavigation.DonNavigationManager
// 0x43C8 (0x45E0 - 0x0218)
class alignas(0x10) ADonNavigationManager final : public AActor
{
public:
	uint8                                         Pad_218[0x1B8];                                    // 0x0218(0x01B8)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBillboardComponent*                    Billboard;                                         // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDonNavVoxelXYZ                        NAVVolumeData;                                     // 0x03E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class AActor*                                 WorldBounds;                                       // 0x03F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldBoundsMargin;                                 // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalCeilingWorldBoundsMargin;                // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VoxelSize;                                         // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdealArcHeightHeuristic;                           // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ECollisionChannel>                     ObstacleQueryChannels;                             // 0x0408(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ECollisionChannel>                     ObstacleForceOpenQueryChannels;                    // 0x0418(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ECollisionChannel>                     ObstacleForceClosedQueryChannels;                  // 0x0428(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnoreForCollision;                        // 0x0438(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 AutoCorrectionGuessList;                           // 0x0448(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MaxPathSolverIterationsPerTick;                    // 0x0458(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCollisionSolverIterationsPerTick;               // 0x045C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMultiThreadingEnabled;                            // 0x0460(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_461[0x3];                                      // 0x0461(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxPathSolverIterationsOnThread;                   // 0x0464(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCollisionSolverIterationsOnThread;              // 0x0468(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VoxelCollisionShapeInflation;                      // 0x046C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrayFromNavigationArcCost;                        // 0x0470(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSmoothAmt;                                      // 0x0474(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          WorldBoundaryVisualizer;                           // 0x0478(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayWorldBoundary;                             // 0x0480(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayWorldBoundaryInGame;                       // 0x0481(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_482[0x2];                                      // 0x0482(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugVoxelsLineThickness;                          // 0x0484(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunDebugValidationsForDynamicCollisions;          // 0x0488(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_489[0x4157];                                   // 0x0489(0x4157)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbortPathfindingTask(class AActor* Actor);
	void AddActorToIgnoreForCollision(class AActor* Actor);
	struct FVector ClampLocationToNavigableWorld(const struct FVector& DesiredLocation);
	void ConstructBuilder();
	void Debug_ClearAllVolumes();
	void Debug_DrawAllVolumes(float LineThickness);
	void Debug_DrawVolumesAroundPoint(const struct FVector& Location, int32 CubeSize, bool DrawPersistentLines, float Duration, float LineThickness, bool bAutoInitializeVolumes);
	void Debug_DrawVoxelCollisionProfile(class UPrimitiveComponent* MeshOrPrimitive, bool bDrawPersistent, float Duration);
	void Debug_FlushDrawnVolumes();
	void Debug_ToggleWorldBoundaryInGame();
	bool FindPathSolution_StressTesting(class AActor* Actor, const struct FVector& Destination, TArray<struct FVector>* PathSolutionRaw, TArray<struct FVector>* PathSolutionOptimized, const struct FDoNNavigationQueryParams& QueryParams, const struct FDoNNavigationDebugParams& DebugParams);
	struct FVector FindRandomPointAroundOriginInNavWorld(class AActor* NavigationActor, const struct FVector& Origin, float Distance, bool* bFoundValidResult, float MaxDesiredAltitude, float MaxZAngularDispacement, int32 MaxAttempts);
	struct FVector FindRandomPointFromActorInNavWorld(class AActor* Actor, float Distance, bool* bFoundValidResult, float MaxDesiredAltitude, float MaxZAngularDispacement, int32 MaxAttempts);
	bool HasTask(class AActor* Actor);
	bool IsDirectPathLineSweep(class UPrimitiveComponent* CollisionComponent, const struct FVector& Start, const struct FVector& End, struct FHitResult* OutHit, bool bFindInitialOverlaps, float CollisionShapeInflation);
	bool IsDirectPathLineTrace(const struct FVector& Start, const struct FVector& End, struct FHitResult* OutHit, const TArray<class AActor*>& ActorsToIgnore, bool bFindInitialOverlaps);
	bool IsDirectPathSweep(class UPrimitiveComponent* CollisionComponent, const struct FVector& Start, const struct FVector& End, struct FHitResult* OutHit, bool bFindInitialOverlaps, float CollisionShapeInflation);
	bool IsLocationBeneathLandscape(const struct FVector& Location, float LineTraceHeight);
	bool IsLocationWithinNavigableWorld(const struct FVector& DesiredLocation);
	bool IsMeshBoundsWithinNavigableWorld(class UPrimitiveComponent* Mesh, float BoundsScaleFactor);
	void RemoveActorToIgnoreForCollision(class AActor* Actor);
	bool ScheduleDynamicCollisionUpdate(class UPrimitiveComponent* Mesh, TDelegate<void(bool bTaskSuccessful)> ResultHandler, class FName CustomCacheIdentifier, bool bReplaceExistingTask, bool bDisableCacheUsage, bool bReloadCollisionCache, bool bUseCheapBoundsCollision, float BoundsScaleFactor, bool bForceSynchronousExecution, bool bDrawDebug);
	bool SchedulePathfindingTaskSimple(class AActor* Actor, const struct FVector& Destination, bool ShowDebugData);
	void VisualizeNAVResult(const TArray<struct FVector>& PathSolution, const struct FVector& Source, const struct FVector& Destination, bool Reset, const struct FDoNNavigationDebugParams& DebugParams, const struct FColor& LineColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DonNavigationManager">();
	}
	static class ADonNavigationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADonNavigationManager>();
	}
};
static_assert(alignof(ADonNavigationManager) == 0x000010, "Wrong alignment on ADonNavigationManager");
static_assert(sizeof(ADonNavigationManager) == 0x0045E0, "Wrong size on ADonNavigationManager");
static_assert(offsetof(ADonNavigationManager, SceneComponent) == 0x0003D0, "Member 'ADonNavigationManager::SceneComponent' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, Billboard) == 0x0003D8, "Member 'ADonNavigationManager::Billboard' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, NAVVolumeData) == 0x0003E0, "Member 'ADonNavigationManager::NAVVolumeData' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, WorldBounds) == 0x0003F0, "Member 'ADonNavigationManager::WorldBounds' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, WorldBoundsMargin) == 0x0003F8, "Member 'ADonNavigationManager::WorldBoundsMargin' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, AdditionalCeilingWorldBoundsMargin) == 0x0003FC, "Member 'ADonNavigationManager::AdditionalCeilingWorldBoundsMargin' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, VoxelSize) == 0x000400, "Member 'ADonNavigationManager::VoxelSize' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, IdealArcHeightHeuristic) == 0x000404, "Member 'ADonNavigationManager::IdealArcHeightHeuristic' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, ObstacleQueryChannels) == 0x000408, "Member 'ADonNavigationManager::ObstacleQueryChannels' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, ObstacleForceOpenQueryChannels) == 0x000418, "Member 'ADonNavigationManager::ObstacleForceOpenQueryChannels' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, ObstacleForceClosedQueryChannels) == 0x000428, "Member 'ADonNavigationManager::ObstacleForceClosedQueryChannels' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, ActorsToIgnoreForCollision) == 0x000438, "Member 'ADonNavigationManager::ActorsToIgnoreForCollision' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, AutoCorrectionGuessList) == 0x000448, "Member 'ADonNavigationManager::AutoCorrectionGuessList' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, MaxPathSolverIterationsPerTick) == 0x000458, "Member 'ADonNavigationManager::MaxPathSolverIterationsPerTick' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, MaxCollisionSolverIterationsPerTick) == 0x00045C, "Member 'ADonNavigationManager::MaxCollisionSolverIterationsPerTick' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, bMultiThreadingEnabled) == 0x000460, "Member 'ADonNavigationManager::bMultiThreadingEnabled' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, MaxPathSolverIterationsOnThread) == 0x000464, "Member 'ADonNavigationManager::MaxPathSolverIterationsOnThread' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, MaxCollisionSolverIterationsOnThread) == 0x000468, "Member 'ADonNavigationManager::MaxCollisionSolverIterationsOnThread' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, VoxelCollisionShapeInflation) == 0x00046C, "Member 'ADonNavigationManager::VoxelCollisionShapeInflation' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, StrayFromNavigationArcCost) == 0x000470, "Member 'ADonNavigationManager::StrayFromNavigationArcCost' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, MaxSmoothAmt) == 0x000474, "Member 'ADonNavigationManager::MaxSmoothAmt' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, WorldBoundaryVisualizer) == 0x000478, "Member 'ADonNavigationManager::WorldBoundaryVisualizer' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, bDisplayWorldBoundary) == 0x000480, "Member 'ADonNavigationManager::bDisplayWorldBoundary' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, bDisplayWorldBoundaryInGame) == 0x000481, "Member 'ADonNavigationManager::bDisplayWorldBoundaryInGame' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, DebugVoxelsLineThickness) == 0x000484, "Member 'ADonNavigationManager::DebugVoxelsLineThickness' has a wrong offset!");
static_assert(offsetof(ADonNavigationManager, bRunDebugValidationsForDynamicCollisions) == 0x000488, "Member 'ADonNavigationManager::bRunDebugValidationsForDynamicCollisions' has a wrong offset!");

// Class DonAINavigation.MarinerDoNNavigationBlocker
// 0x0008 (0x00B8 - 0x00B0)
class UMarinerDoNNavigationBlocker final : public UActorComponent
{
public:
	float                                         TickInterval;                                      // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugDraw;                                        // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MarinerDoNNavigationBlocker">();
	}
	static class UMarinerDoNNavigationBlocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarinerDoNNavigationBlocker>();
	}
};
static_assert(alignof(UMarinerDoNNavigationBlocker) == 0x000008, "Wrong alignment on UMarinerDoNNavigationBlocker");
static_assert(sizeof(UMarinerDoNNavigationBlocker) == 0x0000B8, "Wrong size on UMarinerDoNNavigationBlocker");
static_assert(offsetof(UMarinerDoNNavigationBlocker, TickInterval) == 0x0000B0, "Member 'UMarinerDoNNavigationBlocker::TickInterval' has a wrong offset!");
static_assert(offsetof(UMarinerDoNNavigationBlocker, bDebugDraw) == 0x0000B4, "Member 'UMarinerDoNNavigationBlocker::bDebugDraw' has a wrong offset!");

}

